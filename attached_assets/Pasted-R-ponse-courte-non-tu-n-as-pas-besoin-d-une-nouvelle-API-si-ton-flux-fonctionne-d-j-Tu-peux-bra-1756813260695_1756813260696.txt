Réponse courte : non, tu n’as pas besoin d’une nouvelle API si ton flux fonctionne déjà. Tu peux brancher l’upload KBIS sur l’étape PRO en réutilisant tes mécaniques existantes (Supabase storage + inserts DB + RLS).
Deux questions rapides avant le détail :

Tu utilises déjà Supabase client côté front pour créer/mettre à jour professional_accounts ?

Tu as bien une table verification_documents (ou équivalent) avec un statut (pending/approved/rejected) ?

Ce que je recommande (delta minimal, sans nouvelle API)
A) Frontend (AccountSetup.tsx – étape PRO)

Ajouter l’étape “Vérification (optionnel)” avec drag&drop.

Réutiliser ta logique existante (ex. handleKbisUpload) pour :

Valider type (pdf|jpg|jpeg|png) et taille (≤ 5 Mo).

Nommer le fichier : kbis/${user.id}/${Date.now()}_${slug(nom_entreprise)}.pdf.

Upload direct vers Supabase Storage (bucket verification privé).

Écrire en DB côté front (via Supabase client) dans une transaction logique :

insert into verification_documents (type=KBIS, url=path, status=pending).

update professional_accounts set verification_status='pending', verification_document_id=<id> (ne touche pas au paiement ici).

Boutons :

Passer → tu sautes l’upload, le compte reste verification_status='none'.

Ajouter KBIS → upload + inserts → pending.

Avantage : aucun endpoint supplémentaire, tu capitalises sur RLS + service existant.

B) Variante “propre” si tu veux atomiser (sans “nouvelle API” complexe)

Créer une fonction Postgres (RPC) complete_pro_profile(user_id, kbis_path, …) qui :

Crée/MAJ professional_accounts.

Crée verification_documents.

Met verification_status='pending'.

Tu l’appelles via Supabase RPC : ça te donne l’atome transactionnel sans écrire de route /api.

Reco : RPC > nouvelle route. Moins de code applicatif, transactions DB garanties.

Ce qu’il faut absolument verrouiller
1) RLS & Storage

Bucket storage (privé) + policy upload :

Auth user peut écrire sur kbis/{user_id}/*.

Lecture admin only (service role) pour revue.

RLS (exemples rapides) :

-- verification_documents: l’utilisateur ne voit que ses docs
create policy "own docs read" on verification_documents
for select using (user_id = auth.uid());

create policy "own docs insert" on verification_documents
for insert with check (user_id = auth.uid());

-- professional_accounts: user ne peut MAJ que son compte
create policy "own pro update" on professional_accounts
for update using (owner_user_id = auth.uid());

2) États & règles métier (claires)

professional_accounts.status_abonnement: inactive | active | paused | cancelled

professional_accounts.verification_status: none | pending | verified | rejected

Publication/Postulation d’annonces bloquée si abonnement ≠ active (peu importe la vérif).

Badge Vérifié visible seulement si verification_status='verified'.

3) Admin review

Backoffice :

Liste verification_documents → preview/download.

Boutons Approve / Reject :

Approve → set verification_status='verified', reviewed_by, reviewed_at.

Reject → verification_status='rejected', champ notes (raison), email auto à l’utilisateur.

4) Paiement

L’étape paiement doit précéder la vérification pour débloquer les actions pro.

Si tu utilises Stripe :

Webhook → marquer status_abonnement='active'.

UI : si pas payé → CTA “Activer mon abonnement” ; si payé → CTA “Envoyer mon KBIS (optionnel)”.

Résumé du flux PRO (final)

Créer compte → valider email → premier login.

Choisir PRO → remplir infos pro.

Choisir abonnement → paiement validé → pro actif.

Étape Vérification (optionnel) : upload KBIS → pending.

Admin valide → badge vérifié.

Quand créer une “nouvelle API” ?

Uniquement si tu veux centraliser au serveur : upload signé + multi-opérations atomiques + logs.

Mais tant que Supabase client + RLS + RPC te suffisent, inutile d’ajouter une route /api/users/complete-profile.